# 数据结构和算法

1. 数据结构是指一组数据的存储结构
2. 算法就是操作数据的方法
3. 两者相辅相成

-   数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、 trie 树

-   算法： 递归 排序 二分法查找 搜索 哈希算法 贪心算法 分治算法 回溯算法 动态规划 字符串匹配算法

# 1 复杂度分析

时间、空间复杂度分析,更省空间和时间的解决问题

_复杂度分析法则_

1. 单段代码看高频：比如循环。
2. 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3. 嵌套代码求乘积：比如递归、多重循环等
4. 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。

# 1.2 时间复杂度

> 算法的时间是从其增速的角度度量的

所有代码的执行时间 T(n)与 每行代码的执行次数 n 成正比（O）

O:代表代码执行时间随数据规模增长的变化趋势，也叫渐进时间复杂度简称时间复杂度

1. 多项式量级

-   O（1）常量阶
-   O (logn) 对数阶
-   O（n）线性阶
-   O（n\*logn） 线性对数阶
-   O（n2） 平方阶

2. 非多项式量级

-   O(2^n) 指数阶
-   O（n!） 阶乘

## 1.3 空间复杂度分析

1. 最好
2. 最坏
3. 平均
4. 均摊
5. 时间复杂度

# 2 线性表

数组：基于这两点实现随机访问

-   一种线性表数据结构，
-   用一组连续的内存空间，来存储一组具有相同类型的数组

## 2.1 线性表结构

1. 数组
2. 链表
3. 栈
4. 队列

-   连续的内存空间和相同类型的数据

-   **数组和链表的区别**

    1. 链表适合插入、删除，时间复杂度 O(1)
    2. 数组支持随机访问， 根据下标随机访问时间的复杂度为 O（1）
    3. 数组的 '插入'和 ‘删除’ 是比较低效

## 2.2 链表

> 链表的插入和删除是很快的

-   单链表
-   双向链表
-   循环链表

缓存淘汰策略：

-   先进先出 (FIFO: fist in fist out)
-   最少使用策略(LFU: Leaset Frequently Used)
-   最近最少使用策略（LRU: Leaset Recently Used）

链表

-   单链表
-   双向链表
-   循环链表

1. 单链表

    - 内存块： 链表节点

    - 头结点：第一节节点， 记录链表的地址

    - 尾节点 ：最后一个节点 空地址 null

![](../../img/WX20190505-134351@2x.png)

<img src="../../img/751557889916_.pic.jpg" width="700">

2. 循环链表: 是一种特殊的单链表

3. 双向链表

![](../../img/WX20190505-134351@2x.png)

## 2.3 栈

用数组实现的栈叫 顺序栈

用链表实现的栈 叫 链式栈

-   调用栈:（先进先出）用于存储多个变量

*   所有函数都进入调用栈
*   栈有两种操作： 压入和弹出
*   调用栈可能很长，这将占用大量的内存。

![](../../img/QQ20181228-211306@2x.png)

## 2.4 队列 queue

1. 入队
2. 出队

# 3 选择排序

基本的数据结构

-   链表
-   数组

*   计算机内存犹如一大堆的内存
*   需要存储多个元素的时候，可以使用数据或链表
*   数组的元素在一起
*   数组的读取速度很快
*   链表的插入和删除速度很快

![](../../img/WX20181223-172303@2x.png)

# 4 递归

-   基线： 函数不在调用自己
-   递归条件： 函数调用自己

尾调：如果可以改成写尾递归呢（只用保留一个调用记录），不是所有的语言都支持尾调

# 5 快速排序 - 分而治之（D&C 策略）

### 调用栈

（先进先出）用于存储多个变量

![](../../img/QQ20181228-211306@2x.png)

-   所有函数都进入调用栈
-   栈有两种操作： 压入和弹出
-   调用栈可能很长，这将占用大量的内存。

## 递归 分而治之（D&C 策略）
## 5.1 分而治之（D&C 策略）

> 最简单的数组是不需要排序（操作）的数组

> “D&C 并非可用于解决问题的算法，而是一种解决问题的思路。我们再来看一个例子。”

分田的例子

使用 D&C 解决问题的过程包括两个步骤

-   (1) 找出基线条件，这种条件必须尽可能简单。

-   (2) 不断将问题分解（或者说缩小规模），直到符合基线条件。”

```
def sum(arr):
    total = 0
    for x in arr:
        total +=x
    return  total
print sum([1,21])
```

```
# 列表包含的元素
def count(list):
    if list ==[]:
        return 0
    return  1 + sum[list[1:]]
```

1. 找出基线，一个元素和 0 个元素
2. 每次递归调用都必须离空数组更近些

“编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的”

## 5.2 快速排序

![](../../img/WX20190110-164807@2x.png)

“归纳证明

刚才你大致见识了归纳证明！归纳证明是一种证明算法行之有效的方式，它分两步：基线条件和归纳条件。是不是有点似曾相识的感觉？例如，假设我要证明我能爬到梯子的最上面。递归条件是这样的：如果我站在一个横档上，就能将脚放到下一个横档上。换言之，如果我站在第二个横档上，就能爬到第三个横档。这就是归纳条件。而基线条件是这样的，即我已经站在第一个横档上。因此，通过每次爬一个横档，我就能爬到梯子最顶端。”

# 6 散列表（hash table）

> 也被称为散列映射， 哈希表 、映射 、字典、关联数组 对象
> 将将输入映射到数字
> 散列表将键映射到值

-   它必须是一致
-   输入输入一一对应

*   散列函数总是将同样的输入映射到相同的索引
*   散列函数将不同的输入映射到不同的索引
*   散列函数知道数组有多大，只返回有效的索引
*   散列表（hash table）数据结构

    -   散列函数
    -   数组

*   数组和链表都被直接映射到内存，但是散列表更加复杂，他使用散列函数来确定元素的位置

# 7 二叉树

-   兄弟节点：同属于一个父节点，它们之间互称为兄弟节点

-   根节点： 没有父节点的节点

-   叶节点： 没有子节点的节点

![](../../img/QQ20190529-082651@2x.png)

## 7.1 满二叉树

除了叶子节点之外，每个节点都有左右两个子节点，

![](../../img/QQ20190529-094214@2x.png)

## 7.2 完全二叉树

1. 第一种定义

-   深度为 k
-   n 个节点

当且仅当每个每一个节点都与深度为 k 的满二叉树中，编号从 1-n 的节点一一对应时

![](../../QQ20190529-094214@2x.png)

2. 第一种定义

-   深度为 h
-   除第 h 层外

其他各节点数都达到最大个数， 第 h 层所有节点（不是子节点）都连续集中在最左边

## 7.3 如何存储二叉树

1. 一种是基于指针或者引用的二叉链式存储法，
2. 一种是基于数组的顺序存储法

## 7.4 二叉树的遍历

1. 前序遍历
2. 中序遍历
3. 后序遍历
4. 按层访问（广度优先搜索）

 给定一个数组，比如 1，3，5，6，9，10 来算算，可以构建 6！  中二叉树

前序遍历的递推公式：
preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)

中序遍历的递推公式：
inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)

后序遍历的递推公式：
postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r

# 二叉查找树

二叉查找树最大的特点是 支持动态的数据集合的快速插入 删除 查找 操作

二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值

树高
确定二叉树高度有两种思路：

第一种是深度优先思想的递归，分别求左右子树的高度。当前节点的高度就是左右子树中较大的那个+1；

第二种可以采用层次遍历的方式，每一层记录都记录下当前队列的长度，这个是队尾，每一层队头从 0 开始。然后每遍历一个元素，队头下标+1。直到队头下标等于队尾下标。这个时候表示当前层遍历完成。每一层刚开始遍历的时候，树的高度+1。最后队列为空，就能得到树的高度。

# 红黑树 的一些案例

旋转

# 广度优先算法

> “广度优先搜索是一种用于图的查找算法，”
> 图的组成

# shell

## 执行脚本

1.  赋予权限

- chmod 777 -R hellow
- ./hello.sh

2. 通过 bash

Bash hello.sh

## 基本命令

- echo

* history

  - -c 清空历史明亮
    ![](../../img/QQ20181101-211536@2x.png)

### 输入输出重定向

1. 标准输入和输出

|  设备  | 设备文件名  | 文件描述符 |     类型     |
| :----: | :---------- | :--------- | :----------: |
|  键盘  | /dev/stdin  | 0          |   标准输入   |
| 显示器 | /dev/sdtout | 1          |   标准输出   |
| 显示器 | /dev/sdterr | 2          | 标准错误输出 |

2. 输出重定向

|            类型            | 符号                      | 作用                                                   |
| :------------------------: | :------------------------ | :----------------------------------------------------- |
|       标准输出重定向       | 命令 > 文件               | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备中 |
|                            | 命令 >> 文件              | 以追加的方式，把命令的正确输出输出到指定的文件或设备中 |
|     标准错误输出重定向     | 命令 2> 文件              | 以覆盖的方式，把命令的正确输出输出到指定的文件或设备中 |
|                            | 命令 2 >> 文件            | 以追加的方式，把命令的正确输出输出到指定的文件或设备中 |
| 正确输出和错误输入同时保存 | 命令 > 文件 2> &1         | 以覆盖的方式，把正确输出和错误输出保存到指定的文件     |
|                            | 命令 >> 文件 2> &1        | 以追加的方式，把正确输出和错误输出保存到指定的文件     |
|                            | 命令 &> 文件              | 以覆盖的方式，把正确输出和错误输出保存到指定的文件     |
|                            | 命令 &>> 文件             | 以追加的方式，把正确输出和错误输出保存到指定的文件     |
|                            | 命令 >> 文件 1 2>> 文件 2 | 把正确输出追加到文件 1 中， 把错误输出指定的文件 2     |

3. 多命令书序执行

| 多命令执行 | 格式               | 作用                                                                 |
| :--------: | :----------------- | :------------------------------------------------------------------- |
|     ;      | 命令 1 ; 命令 2    | 多个明亮顺序执行，命令之间没有任何的联系                             |
|     &&     | 命令 1 && 命令 2   | 命令 1 执行正确，命令 2 才会执行, 当 1 不执行，2 不会执行            |
|    \|\|    | 命令 1 \|\| 命令 2 | 命令 1 执行正确，命令 2 不会执行, 命令 1 执行不正确，命令 2 才会执行 |

```
ls ; date; cd /home; pwd
```

4. 管道符

命令 1 | 命令 2
`#命令1 的正确输出作为命令2操作对象`

注意是操作主体

```
# 错误，后者并没找到主体 颠倒了 思路也不对
 tar -zxcf | find . -name "*gz"
```

```
tar命令批量解压方法总结
ls *.tar.gz | xargs -n1 tar xzvf
```

```
ll -a /etc | more （主体）
```

5. 内容上搜索

`grep 内容 目标文件`

```
netstat -an  | grep ESTABLISHED (主体)
```

6. 通配符

| 通配符 | 作用                                                                     |
| :----: | :----------------------------------------------------------------------- |
|   ？   | 匹配任意一个字符                                                         |
|   \*   |                                                                          |
|   []   | 匹配中括号任意一个字符,[abc] 代表一定匹配一个字符 ，或者 a,或者 b,或者 c |
|  [-]   | 匹配中括号任意一个字符,- 代表一个范围 ，[a-z] 代表匹配一个小写字母       |
|  [^]   | 表示匹配不是中括号内任意一个字符,[^0-9] 代表匹配一个不是数字的字符       |

```
 1957  touch abc
 1958  touch abcd
 1959  touch 012
 1960  touch 0abc
 1961  ls ?abc
 1963  ls [0-9]a
 1964  ls [0-9]abc
 1965  ls [^0-9]*
```

7. Bash 中其他特殊符号

| 符号 | 作用                                                                      |
| :--: | :------------------------------------------------------------------------ |
|  ‘’  | 所用特殊字符都没有含义                                                    |
|  ""  | 所用特殊字符都没有含义。但是‘$’（调用变量值）. '`'（引用命令） ‘\’ 除外， |
| $()  | 引用系统命令                                                              |
|  $   | 用于调用变量的值                                                          |

```
name=sc // 不要有空格
echo '$name'
echo "$name"
echo '$(date)'
echo "$(date)"

“$PWD”
echo $(ls)
```

## 变量

1. 变量设置规则

- 在 bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须是制定变量类型为数值型
- 变量用等号连接值，等号左右两侧不能有空格
- 如果把命令的结果作为变量值赋予变量，则需要使用反引号或$()包含命令

```
name=$(date)
echo $name;
```

- 变量分类

  - 用户自定义变量

  * 环境变量
  * 位置参数变量
  * 预定义变量

#### 用户自定义变量

- 允许用户自定义变量

```
aa=123
aa=${aa}789
```

- 查看变量

`set`

- 删除变量

`unset $name;`

#### 环境变量

用户自定义变量只在当前的 shell 有效，而环境变量会在当前 shell 和这个 shell 的所写的子 shell 当中有效

- 申明变量

`export 变量名=变量值`

- 查询变量

`env`

- 删除变量

`unset 变领名`

#### 位置参数变量
